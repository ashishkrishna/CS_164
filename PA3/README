README file for Programming Assignment 3
========================================

Your directory should now contain the following files:

 build.xml
 PA3.pdf
 cool-manual.pdf
 README
 cool.cup
 bad.cl
 good.cl
 tests/*
 compare-parser.py
 coolc.py
 parser.py
 mycoolc.py
 myparser.py
 runmips.py
 coolc.jar
 trap_handler.mars
 cool-tree.java
 cool-tree.aps
 AbstractSymbol.java
 AbstractTable.java
 BoolConst.java
 CgenClassTable.java	  
 CgenNode.java
 CgenSupport.java
 ClassTable.java
 CoolParser.java
 CoolTokenLexer.java
 Flags.java
 IdSymbol.java
 IdTable.java
 IntSymbol.java
 IntTable.java
 ListNode.java
 Parser.java
 StringSymbol.java
 StringTable.java
 SymbolTable.java
 TokenConstants.java
 TreeConstants.java
 TreeNode.java
 Utilities.java
 *.java			  other generated files

	The build.xml contains targets for compiling and running your
	program. DO NOT MODIFY.
   
	PA3.pdf is the specification of the third programming assignment.
	Please read it carefully.

	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.cup is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the CUP documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	tests is a directory containing ten test cases. DO NOT MODIFY.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).  From
	this file, cool-tree.java is automatically generated by a
	utility that compiles the specification into Java classes for
	constructing tree nodes.  This file is provided for your
	reference.  DO NOT MODIFY.

        TreeNode.java and ListNode.java contain definitions used by the
        tree package. DO NOT MODIFY.  

        Parser.java contains a driver to test the parser. DO NOT MODIFY.

	Flags.java implements routines for parsing command line
	flags. DO NOT MODIFY.

        tests is a directory containing ten test cases with expected outputs.
        DO NOT MODIFY.

        The rest of the files are created as byproducts of `CUP', or
        are internal parser support files.  DO NOT MODIFY.
        `CoolParser.java' is the generated Java file containing the
        parser.  DO NOT MODIFY this file directly; instead, edit
        cool.cup and this file will be regenerated automatically.

	myparser.py and parser.py are a python script driveing the parser.
	compare-parser.py is a python script which compares the outcome
	of your parser with the reference. DO NOT MODIFY.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% ant parser

	To test your parser on a file 'foo.cl' type

	% python myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.  Don't worry if the line numbers you get by
	running Java version of the parser are slightly off as compared
	to the "official" parser.

	To run your parser on the files good.cl and bad.cl type:

	% ant test

        To run ten examples in tests directory type:

        % ant test-all

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% python mycoolc.py foo.cl

        To run the reference parser on a file 'fool.cl':

        % pythone parser.py foo.cl

        To easily compare your parser and the reference parser:

        % python compare-parser.py foo.cl

        This will create a diff file (fool.cl.diff), when two parsers
	disagree.

	To turn in your work type:

	% ant submit-clean

	And run the "submit PA3" program. This will automatically collect the
	files good.cl, bad.cl, good.output, bad.output, README, and cool.cup 
        file. Don't forget to edit this README file to include your write-up, 
        and to write your own test cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------
We extended productions for the expression (expr) nonterminal by referencing
the Cool syntax layout given on pg. 16 of the Cool manual. The design decisions we made 
with respect to containers, namely blocks, feature lists, and actual lists 
were largely based upon the existing skeleton code. We provided an empty container case 
for each of these nonterminals, as well as one more population productions (the non-
empty cases). These population productions would either continue to populate an existing 
container or create a new one and commence population. We added additional nonterminals 
in order to handle feature, case, let, and actual atomics. The resulting productions for 
these nonterminals were again directly drawn from the Cool syntax layout described in
the manual. 
We implemented error handling for classes, let statements, and features. The error handling
was symmetric to the case already defined in a production for the program nonterminal, and 
consisted, most often of a simple "error SEMI", in order to coerce the parser to continue 
parsing after the error. The notable exception to this was in the let statement production
block, where we also defined a "error in expr:e1" in order to handle errors in the first 
part of a recursive definition (a let expression with multiple local variables defined within
its scope).
The inherent ambiguity of let statements did not pose a major problem. Our parser automatically
parsed as far right as it legally could, and as a result we never encountered any side-effects
from the ambiguity in our tests. We did define a separate block for let statements, and created
a let nonterminal as well. This was necessary due to the recursive nature of let statements of the
form: 
let <id1> : <type1> [<- <expr1>] ...., <idn> : <typen> [<- <exprn>] in <expr>
Defining multiple local variables (<idn>'s) required a recursive nesting of let statements, as we 
saw from the output of the reference parser provided. 
Our language remains inherently ambiguous, based on cool.output, where there are a number of 
shift/reduce conflicts. However, this is not inherently problematic. We found that on all our test cases, 
the default resolution of these conflicts posed no problems, and the test outputs seemed to match
the provided reference. However, in the context of building a commercial grade compiler destined
for widespread useage, these conflicts should be considered more carefully, in order to prevent any
and all possible conflicts that could potentially arise. 
The test cases we selected included Cool files that were examples in PA1. We created a lot of tests
with let expressions, partly in order to ensure that the ambiguity in its definitions posed no problems.
We do not provide support for the parsing of exceptions, since we were not required to do so.

